<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->


	<!-- PackageName is printed as title by the top-level template -->
	
		<p><code>import "."</code></p>
	
	<p>
Package containing a high performance and lightweight wrapper around appengine/datastore,
providing Active Record and DBO style management of data.
</p>
<p>
To persist records, use Record.Put().  To retrieve them, use Model.Find(id).
</p>
<pre>// create a new model for &#39;people&#39;
people := NewModel(&#34;people&#34;)

// create a new person
mat := people.New()
mat.
  SetString(&#34;name&#34;, &#34;Mat&#34;)
  SetInt64(&#34;age&#34;, 28)
  .Put()

// load person with ID 1
person := people.Find(1)

// change some fields
person.SetInt64(&#34;age&#34;, 29).Put()

// load all people
peeps := people.All()

// delete mat
mat.Delete()
</pre>

	
		
			<p>
			<h4>Package files</h4>
			<span style="font-size:90%">
			
				<a href="/">appengine_context.go</a>
			
				<a href="/">data.go</a>
			
				<a href="/">errors.go</a>
			
				<a href="/">events.go</a>
			
				<a href="/">model.go</a>
			
				<a href="/">namespace.go</a>
			
				<a href="/">record.go</a>
			
			</span>
			</p>
		
	
	
	
		<h2 id="Variables">Variables</h2>
		
			<p>
The following errors are defined in this package:
</p>

			<pre>var (

    <span class="comment">// Error returned when an event callback cancels an operation</span>
    ErrOperationCancelledByEventCallback = os.NewError(&#34;gaerecords: Operation was cancelled by an event callback.&#34;)
)</pre>
		
			<p>
The ID value of a record that indicates there is no ID.  A record
will have no ID if it has not yet been saved, or if it has been deleted.
</p>

			<pre>var NoIDValue int64 = 0</pre>
		
	
	
		
			
			
			<h2 id="CreateAppEngineContext">func <a href="/?s=295:363#L3">CreateAppEngineContext</a></h2>
			<p><code>func CreateAppEngineContext(request *http.Request) appengine.Context</code></p>
			<p>
Creates a new appengine.Context object from the given request.
At least one call to CreateAppEngineContext(*http.Request) is required per
request to ensure gaerecords uses the correct context.
</p>

		
			
			
			<h2 id="GetAppEngineContext">func <a href="/?s=565:609#L14">GetAppEngineContext</a></h2>
			<p><code>func GetAppEngineContext() appengine.Context</code></p>
			<p>
Gets the current appengine.Context object used by gaerecords.
</p>

		
	
	
		
			
			<h2 id="Event">type <a href="/?s=513:567#L17">Event</a></h2>
			<p>
Type that enables eventing on an object.
</p>
<pre>// define a struct
type MyObject struct {

  // add an event
  OnSomething Event

}

// create an instance of our type
obj := new(MyObject)

// add an event listener
obj.OnSomething.Do(func(e *EventContext){
  // TODO: handle the event
})

// Trigger the event
obj.OnSomething.Trigger()
</pre>

			<p><pre>type Event struct {
    Callbacks []func(*EventContext)
}</pre></p>
			
			
			
			
				
				<h3 id="Event.Do">func (*Event) <a href="/?s=735:776#L23">Do</a></h3>
				<p><code>func (e *Event) Do(f func(*EventContext))</code></p>
				<p>
Adds a callback func to this event.  When Trigger() is called, the func passed
in will get called, provided no other funcs have cancelled the event beforehand.
</p>

			
				
				<h3 id="Event.HasCallbacks">func (*Event) <a href="/?s=883:918#L28">HasCallbacks</a></h3>
				<p><code>func (e *Event) HasCallbacks() bool</code></p>
				<p>
Gets whether the event has any registered callbacks or not.
</p>

			
				
				<h3 id="Event.Trigger">func (*Event) <a href="/?s=1231:1289#L39">Trigger</a></h3>
				<p><code>func (e *Event) Trigger(args ...interface{}) *EventContext</code></p>
				<p>
Triggers the event with the specified arguments.
</p>
<p>
If any callbacks are registered, a new EventContext is created
and then TriggerWithContext() is called.
</p>
<p>
If no callbacks are registered, Trigger() does nothing but still
returns a usable EventContext object.
</p>

			
				
				<h3 id="Event.TriggerWithContext">func (*Event) <a href="/?s=2177:2248#L69">TriggerWithContext</a></h3>
				<p><code>func (e *Event) TriggerWithContext(context *EventContext) *EventContext</code></p>
				<p>
Triggers the event with an existing EventContext object.
</p>
<p>
All funcs that have been registered with the Do() method will
be called.
</p>
<p>
If no callbacks are registered, TriggerWithContext() does nothing.
</p>
<p>
If any of the funcs sets the EventContext.Cancel property to true, no
more callbacks will be called.
</p>
<p>
Trigger() returns the EventContext that was passed through each callback which is useful
for checking if the event chain was cancelled, or if any data was collected along the way.
</p>
<p>
Usually this method is called after a Before* event that produces an EventContext object.
This allows other events (i.e. After*) to share the same context.
</p>

			
		
			
			<h2 id="EventContext">type <a href="/?s=2657:3037#L100">EventContext</a></h2>
			<p>
Type that provides context to event callbacks.
</p>

			<p><pre>type EventContext struct {

    <span class="comment">// Whether the event should be cancelled or not.  If set to true inside a </span>
    <span class="comment">// callback func, no subsequent callbacks will be called.</span>
    Cancel bool

    <span class="comment">// Array holding the arguments passed to Trigger() if any.</span>
    Args []interface{}

    <span class="comment">// The index of this callback in the chain.  Will be 0 for first callback etc.</span>
    Index int
    <span class="comment">// contains filtered or unexported fields</span>
}</pre></p>
			
			
			
			
				
				<h3 id="EventContext.Data">func (*EventContext) <a href="/?s=3335:3387#L128">Data</a></h3>
				<p><code>func (c *EventContext) Data() map[string]interface{}</code></p>
				<p>
Gets a map[string]interface{} of the data for this context.  Will return an
empty (but non-nil) map if no data has been provided.
</p>

			
				
				<h3 id="EventContext.Set">func (*EventContext) <a href="/?s=3058:3129#L116">Set</a></h3>
				<p><code>func (c *EventContext) Set(key string, value interface{}) *EventContext</code></p>
				<p>
Sets some data.
</p>

			
		
			
			<h2 id="Model">type <a href="/?s=198:2573#L2">Model</a></h2>
			<p>
Represents a single model. A model is a class of data.
</p>
<pre>// create a new model for &#39;people&#39;
people := NewModel(&#34;people&#34;)
</pre>

			<p><pre>type Model struct {

    <span class="comment">// Event that gets triggered after a record has been created.</span>
    <span class="comment">// Useful for initializing Records.</span>
    <span class="comment">//</span>
    <span class="comment">//   Args[0] - The *Record that has been created</span>
    AfterNew Event

    <span class="comment">// Event that gets triggered after a record of this kind has been</span>
    <span class="comment">// found.  Useful for any processing of records after they have been loaded.</span>
    <span class="comment">// For any operations that cause multiple finds (i.e. All()) this event</span>
    <span class="comment">// will be triggered for each record.</span>
    <span class="comment">//</span>
    <span class="comment">//   Args[0] - The *Record that has been found.</span>
    <span class="comment">//</span>
    AfterFind Event

    <span class="comment">// Event that gets triggered before a record is deleted. The Args will</span>
    <span class="comment">// always contain the ID of the record being deleted, and depending on the</span>
    <span class="comment">// operation, the second argument could be the *Record itself.</span>
    <span class="comment">//</span>
    <span class="comment">// Setting Cancel to true will cancel the delete operation.</span>
    <span class="comment">//</span>
    <span class="comment">//   Args[0] - ID (int64) of the record that is about to be deleted.</span>
    <span class="comment">//   Args[1] - *Record to be deleted (if available)</span>
    <span class="comment">//</span>
    BeforeDelete Event

    <span class="comment">// Event that gets triggered after a record has been deleted by ID. The Args will</span>
    <span class="comment">// always contain the ID of the record being deleted, and depending on the</span>
    <span class="comment">// operation, the second argument could be the *Record itself.</span>
    <span class="comment">///</span>
    <span class="comment">// The EventContext is the same one that was passed to BeforeDelete.</span>
    <span class="comment">//</span>
    <span class="comment">//   Args[0] - ID (int64) of the record that was just deleted.</span>
    <span class="comment">//   Args[1] - *Record that was deleted (if available)</span>
    <span class="comment">//</span>
    AfterDelete Event

    <span class="comment">// Event that gets triggered before a record gets Put into the datastore.</span>
    <span class="comment">// Use Args[0].(*Record).IsPersisted() to find out whether the record is being</span>
    <span class="comment">// saved or updated.</span>
    <span class="comment">//</span>
    <span class="comment">// Setting Cancel to true will prevent the record from being Put</span>
    <span class="comment">// </span>
    <span class="comment">//   Args[0] - The *Record that is about to be Put</span>
    <span class="comment">//</span>
    BeforePut Event

    <span class="comment">// Event that gets triggered after a record has been Put.</span>
    <span class="comment">// The EventContext is the same one that was passed to BeforePut.</span>
    <span class="comment">//</span>
    <span class="comment">//   Args[0] - The *Record that was just Put</span>
    <span class="comment">// </span>
    AfterPut Event

    <span class="comment">// Event that gets triggered after a record field has been changed</span>
    <span class="comment">// using one of the Set*() methods.</span>
    <span class="comment">//</span>
    <span class="comment">//   Args[0] - The record that changed</span>
    <span class="comment">//   Args[1] - The key of the field that changed</span>
    <span class="comment">//   Args[2] - The new value of the field</span>
    <span class="comment">//   Args[3] - The old value of the field (or nil if it&#39;s a new field)</span>
    OnChanged Event
    <span class="comment">// contains filtered or unexported fields</span>
}</pre></p>
			
			
			
				
				<h3 id="Model.NewModel">func <a href="/?s=2760:2799#L77">NewModel</a></h3>
				<p><code>func NewModel(recordType string) *Model</code></p>
				<p>
Creates a new model for data classified by the specified recordType.
</p>
<p>
For example, the following code creates a new Model called &#39;people&#39;:
</p>
<pre>people := NewModel(&#34;people&#34;)
</pre>

			
			
				
				<h3 id="Model.All">func (*Model) <a href="/?s=3968:4011#L127">All</a></h3>
				<p><code>func (m *Model) All() ([]*Record, os.Error)</code></p>
				<p>
Finds all records of this type.
</p>
<pre>people := NewModel(&#34;people&#34;)
everyone := people.All()
</pre>
<p>
Raises events for each record:
</p>
<pre>Model.AfterFind with Args(record)
</pre>

			
				
				<h3 id="Model.Delete">func (*Model) <a href="/?s=4373:4414#L140">Delete</a></h3>
				<p><code>func (m *Model) Delete(id int64) os.Error</code></p>
				<p>
Deletes a single record of this type.  Returns nil if successful, otherwise
the datastore error that was returned.
</p>
<pre>people := NewModel(&#34;people&#34;)
people.Delete(1)
</pre>
<p>
Raises events:
</p>
<pre>Model.BeforeDelete with Args(id, nil)
Model.AfterDelete with Args(id, nil)
</pre>
<p>
Note: The Record will not be passed to the events.
</p>

			
				
				<h3 id="Model.Find">func (*Model) <a href="/?s=3710:3760#L117">Find</a></h3>
				<p><code>func (m *Model) Find(id int64) (*Record, os.Error)</code></p>
				<p>
Finds the record of this type with the specified id.
</p>
<pre>people := NewModel(&#34;people&#34;)
firstPerson := people.Find(1)
</pre>
<p>
Raises events:
</p>
<pre>Model.AfterFind with Args(record)
</pre>

			
				
				<h3 id="Model.New">func (*Model) <a href="/?s=3005:3034#L91">New</a></h3>
				<p><code>func (m *Model) New() *Record</code></p>
				<p>
Creates a new record of this type.
</p>
<pre>people := NewModel(&#34;people&#34;)
person1 := people.New()
person2 := people.New()
</pre>

			
				
				<h3 id="Model.NewKey">func (*Model) <a href="/?s=4600:4639#L150">NewKey</a></h3>
				<p><code>func (m *Model) NewKey() *datastore.Key</code></p>
				<p>
Creates a new datastore Key for this kind of record.
</p>

			
				
				<h3 id="Model.NewKeyWithID">func (*Model) <a href="/?s=4800:4853#L155">NewKeyWithID</a></h3>
				<p><code>func (m *Model) NewKeyWithID(id int64) *datastore.Key</code></p>
				<p>
Creates a new datastore Key for this kind of record with the specified ID.
</p>

			
				
				<h3 id="Model.RecordType">func (*Model) <a href="/?s=3224:3259#L97">RecordType</a></h3>
				<p><code>func (m *Model) RecordType() string</code></p>
				<p>
Gets the record type of the model as a string.  This is the string you specify
when calling NewModel(string) and is used as the Kind in the datasource keys.
</p>

			
				
				<h3 id="Model.String">func (*Model) <a href="/?s=3348:3379#L102">String</a></h3>
				<p><code>func (m *Model) String() string</code></p>
				<p>
Gets a human readable string representation of this model.
</p>

			
		
			
			<h2 id="Record">type <a href="/?s=403:785#L5">Record</a></h2>
			<p>
Represents a single record of data (like a single row in a database, or a single resource
on a web server).  Synonymous with an Entity in appengine/datastore.
</p>

			<p><pre>type Record struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre></p>
			
			
			
				
				<h3 id="Record.NewRecord">func <a href="/?s=1008:1044#L31">NewRecord</a></h3>
				<p><code>func NewRecord(model *Model) *Record</code></p>
				<p>
Creates a new record of the given Model type.  Not recommended.  Instead call the
New() method on the model object itself.
</p>

			
			
				
				<h3 id="Record.DatastoreKey">func (*Record) <a href="/?s=5313:5359#L192">DatastoreKey</a></h3>
				<p><code>func (r *Record) DatastoreKey() *datastore.Key</code></p>
				<p>
Gets the appengine/datastore Key for this record.  If this record is persisted in the
datastore it wil be a complete key, otherwise, this method will return an incomplete key.
</p>

			
				
				<h3 id="Record.Delete">func (*Record) <a href="/?s=4976:5010#L181">Delete</a></h3>
				<p><code>func (r *Record) Delete() os.Error</code></p>
				<p>
Deletes this record.  Returns nil if successful, otherwise returns the os.Error
that was retrned by appengime/datastore.
</p>
<pre>record.Delete()
</pre>
<p>
Raises events:
</p>
<pre>Model.BeforeDelete with Args(id, record)
Model.AfterDelete with Args(id, record)
</pre>
<p>
Note: The Record will be passed to the events.
</p>

			
				
				<h3 id="Record.Fields">func (*Record) <a href="/?s=6663:6711#L261">Fields</a></h3>
				<p><code>func (r *Record) Fields() map[string]interface{}</code></p>
				<p>
Gets the internal storage map (map[string]interface{}) that contains the
persistable fields for this record.  Instead of manipulating this object directly,
you should use the Get*() and Set*() methods.
</p>

			
				
				<h3 id="Record.Get">func (*Record) <a href="/?s=6975:7019#L274">Get</a></h3>
				<p><code>func (r *Record) Get(key string) interface{}</code></p>
				<p>
Gets the value of a field in a record.  Strongly typed alternatives are provided and recommended
to use where possible.
</p>

			
				
				<h3 id="Record.GetBool">func (*Record) <a href="/?s=8558:8599#L335">GetBool</a></h3>
				<p><code>func (r *Record) GetBool(key string) bool</code></p>
				<p>
Gets the bool value of a field with the specified key.
</p>

			
				
				<h3 id="Record.GetFloat64">func (*Record) <a href="/?s=8263:8310#L325">GetFloat64</a></h3>
				<p><code>func (r *Record) GetFloat64(key string) float64</code></p>
				<p>
Gets the float64 value of a field with the specified key.
</p>

			
				
				<h3 id="Record.GetInt64">func (*Record) <a href="/?s=7977:8020#L315">GetInt64</a></h3>
				<p><code>func (r *Record) GetInt64(key string) int64</code></p>
				<p>
Gets the int64 value of a field with the specified key.
</p>

			
				
				<h3 id="Record.GetKeyField">func (*Record) <a href="/?s=8845:8900#L345">GetKeyField</a></h3>
				<p><code>func (r *Record) GetKeyField(key string) *datastore.Key</code></p>
				<p>
Gets the *datastore.Key value of a field with the specified key.
</p>

			
				
				<h3 id="Record.GetString">func (*Record) <a href="/?s=7708:7753#L305">GetString</a></h3>
				<p><code>func (r *Record) GetString(key string) string</code></p>
				<p>
Gets a string field
</p>

			
				
				<h3 id="Record.ID">func (*Record) <a href="/?s=2356:2383#L81">ID</a></h3>
				<p><code>func (r *Record) ID() int64</code></p>
				<p>
Gets the unique ID for this record.  A record will be assigned a unique ID
only when it is persisted in the datastore.  Otherwise, the ID will be equal to NoIDValue.
Use IsPersisted() to check if a record has been persisted in the datastore or not.
</p>

			
				
				<h3 id="Record.IsPersisted">func (*Record) <a href="/?s=6292:6327#L249">IsPersisted</a></h3>
				<p><code>func (r *Record) IsPersisted() bool</code></p>
				<p>
Whether this record has been persisted in the
datastore or not, i.e. record.ID != NoIDValue
</p>

			
				
				<h3 id="Record.Load">func (*Record) <a href="/?s=3421:3480#L120">Load</a></h3>
				<p><code>func (r *Record) Load(c &lt;-chan datastore.Property) os.Error</code></p>
				<p>
CAUTION: This method does NOT load persisted records.  See Find().
PropertyLoadSaver.Load takes a channel of datastore.Property objects and
applies them to the internal Fields() object.
Used internally by the datastore.
</p>

			
				
				<h3 id="Record.Model">func (*Record) <a href="/?s=1420:1451#L51">Model</a></h3>
				<p><code>func (r *Record) Model() *Model</code></p>
				<p>
Gets the current Model object representing the type of this record.
</p>

			
				
				<h3 id="Record.NeedsPersisting">func (*Record) <a href="/?s=2947:2986#L106">NeedsPersisting</a></h3>
				<p><code>func (r *Record) NeedsPersisting() bool</code></p>
				<p>
Gets whether this record needs persisting in the datastore or not.  If this
record is synched with the datastore (as far as this record knows) it will
return false, otherwise, if something has changed or this is a new record, true
will be returned.
</p>

			
				
				<h3 id="Record.Put">func (*Record) <a href="/?s=4611:4642#L169">Put</a></h3>
				<p><code>func (r *Record) Put() os.Error</code></p>
				<p>
Saves or updates this record.  Returns nil if successful, otherwise returns the os.Error
that was retrned by appengime/datastore.
</p>
<pre>record.Put()
</pre>
<p>
Raises events:
</p>
<pre>Model.BeforePut with Args(record)
Model.AfterPut with Args(record)
</pre>

			
				
				<h3 id="Record.Save">func (*Record) <a href="/?s=3843:3902#L135">Save</a></h3>
				<p><code>func (r *Record) Save(c chan&lt;- datastore.Property) os.Error</code></p>
				<p>
CAUTION: This method does NOT persist records.  See Put().
PropertyLoadSaver.Save writes datastore.Property objects and
representing the Fields() of this record to the specified channel.
Used internally by the datastore to persist the values.
</p>

			
				
				<h3 id="Record.Set">func (*Record) <a href="/?s=7341:7400#L286">Set</a></h3>
				<p><code>func (r *Record) Set(key string, value interface{}) *Record</code></p>
				<p>
Sets a field in the record.  The value must be an acceptable datastore
type or another Record.  Strongly typed alternatives are provided and recommended
to use where possible.
</p>

			
				
				<h3 id="Record.SetBool">func (*Record) <a href="/?s=8689:8745#L340">SetBool</a></h3>
				<p><code>func (r *Record) SetBool(key string, value bool) *Record</code></p>
				<p>
Sets the bool value of a field with the specified key.
</p>

			
				
				<h3 id="Record.SetDatastoreKey">func (*Record) <a href="/?s=5639:5699#L213">SetDatastoreKey</a></h3>
				<p><code>func (r *Record) SetDatastoreKey(key *datastore.Key) *Record</code></p>
				<p>
Sets the datastore Key and updates the records ID if needed
</p>

			
				
				<h3 id="Record.SetFloat64">func (*Record) <a href="/?s=8406:8468#L330">SetFloat64</a></h3>
				<p><code>func (r *Record) SetFloat64(key string, value float64) *Record</code></p>
				<p>
Sets the float64 value of a field with the specified key.
</p>

			
				
				<h3 id="Record.SetInt64">func (*Record) <a href="/?s=8112:8170#L320">SetInt64</a></h3>
				<p><code>func (r *Record) SetInt64(key string, value int64) *Record</code></p>
				<p>
Sets the int64 value of a field with the specified key.
</p>

			
				
				<h3 id="Record.SetKeyField">func (*Record) <a href="/?s=9010:9080#L350">SetKeyField</a></h3>
				<p><code>func (r *Record) SetKeyField(key string, value *datastore.Key) *Record</code></p>
				<p>
Sets the *datastore.Key value of a field with the specified key.
</p>

			
				
				<h3 id="Record.SetModel">func (*Record) <a href="/?s=1674:1721#L58">SetModel</a></h3>
				<p><code>func (r *Record) SetModel(model *Model) *Record</code></p>
				<p>
Sets the current Model object representing the type of this record.  It is recommended that
you create records with model.New() or use NewRecord(*Model) instead of using this method
directly.
</p>

			
				
				<h3 id="Record.SetNeedsPersisting">func (*Record) <a href="/?s=3091:3146#L111">SetNeedsPersisting</a></h3>
				<p><code>func (r *Record) SetNeedsPersisting(value bool) *Record</code></p>
				<p>
Sets whether this record needs persisting or not.  Advanced use only.
</p>

			
				
				<h3 id="Record.SetString">func (*Record) <a href="/?s=7826:7886#L310">SetString</a></h3>
				<p><code>func (r *Record) SetString(key string, value string) *Record</code></p>
				<p>
Sets the string value of a field
</p>

			
				
				<h3 id="Record.String">func (*Record) <a href="/?s=1816:1848#L64">String</a></h3>
				<p><code>func (r *Record) String() string</code></p>
				<p>
Gets a human readable string representation of this record
</p>

			
		
	
	


	<h2>Other packages</h2>
	<p>
	
	
	<a href="?p=main">main</a><br />
	
	</p>


